#!/usr/bin/env node
// Generated by CoffeeScript 1.4.0
(function() {
  var TcpConnection, callout, charm, client, color, colors, config, dgram, drawPresence, iron, messageList, msgLine, net, nick, os, parseMsg, parseRawMsg, password, port, positionForInput, present, printNewMessage, randomColor, see, send, sendRaw, server, stdin, stylize, tcpconnection,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  os = require('os');

  net = require("net");

  charm = require('charm')();

  dgram = require("dgram");

  iron = require("iron");

  password = process.argv[2];

  present = {};

  config = {};

  try {
    config = require("" + process.env.HOME + "/.nackchannelrc.json");
  } catch (_error) {}

  nick = config.nick || process.env.USER;

  nick += "{reset}";

  colors = ["blue", "cyan", "green", "magenta", "red", "white", "yellow"];

  randomColor = colors[Math.floor(Math.random() * colors.length)];

  color = randomColor;

  if (typeof config.color !== 'undefined') {
    color = config.color;
  }

  server = dgram.createSocket("udp4");

  client = dgram.createSocket("udp4");

  port = 41234;

  TcpConnection = (function() {

    function TcpConnection() {
      this.broadcast = __bind(this.broadcast, this);

      this.getMyIP = __bind(this.getMyIP, this);

      this.sendRaw = __bind(this.sendRaw, this);

      this.send = __bind(this.send, this);

      this.receive = __bind(this.receive, this);

      this.close = __bind(this.close, this);

      this.connectTo = __bind(this.connectTo, this);

      var conn,
        _this = this;
      this.connections = {};
      this.getMyIP();
      conn = this;
      server = net.createServer(function(s) {
        s.on("data", _this.receive);
        return s.on("error", _this.err);
      }).listen(0);
      this.port = server.address().port;
      this.broadcast();
      setInterval(this.broadcast, 10e3);
    }

    TcpConnection.prototype.err = function(e) {
      return console.log(e);
    };

    TcpConnection.prototype.connectTo = function(obj) {
      var socket, _base, _name;
      if (obj.port == null) {
        return;
      }
      (_base = this.connections)[_name = obj.address] || (_base[_name] = {});
      if (this.connections[obj.address][obj.port] != null) {
        return;
      }
      socket = net.connect({
        port: obj.port,
        address: obj.address
      });
      socket.on("error", this.err);
      socket.on("close", this.close(obj.address, obj.port));
      return this.connections[obj.address][obj.port] = {
        nick: obj.nick,
        color: color,
        socket: socket
      };
    };

    TcpConnection.prototype.close = function(address, port) {
      var _this = this;
      return function() {
        delete _this.connections[address][port];
        return drawPresence();
      };
    };

    TcpConnection.prototype.receive = function(data) {
      return parseRawMsg(data.toString());
    };

    TcpConnection.prototype.send = function(obj) {
      var msg,
        _this = this;
      if (password) {
        iron.seal(obj, password, iron.defaults, function(err, sealed) {
          return _this.sendRaw(sealed);
        });
      } else {
        msg = JSON.stringify(obj);
        this.sendRaw(msg);
      }
      if (obj.payload != null) {
        return positionForInput();
      }
    };

    TcpConnection.prototype.sendRaw = function(msg) {
      var address, socket, _results;
      msg = new Buffer(msg);
      _results = [];
      for (address in this.connections) {
        _results.push((function() {
          var _results1;
          _results1 = [];
          for (port in this.connections[address]) {
            socket = this.connections[address][port].socket;
            _results1.push(socket.write(msg));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    TcpConnection.prototype.getMyIP = function() {
      var address, interfaces, k, _results;
      interfaces = os.networkInterfaces();
      _results = [];
      for (k in interfaces) {
        _results.push((function() {
          var _i, _len, _ref, _results1;
          _ref = interfaces[k];
          _results1 = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            address = _ref[_i];
            if (address.internal === false && address.family === "IPv4") {
              _results1.push(this.address = address.address);
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    TcpConnection.prototype.broadcast = function() {
      return send({
        port: this.port,
        address: this.address,
        nick: nick,
        color: color
      });
    };

    return TcpConnection;

  })();

  server.bind(port);

  server.addMembership('224.0.0.0');

  charm.pipe(process.stdout);

  charm.reset();

  stylize = function(msg) {
    var matcher, styles;
    styles = {
      reset: 0,
      blink: 5,
      bold: 1,
      underline: 4,
      black: 30,
      blue: 34,
      cyan: 36,
      green: 32,
      magenta: 35,
      red: 31,
      white: 37,
      yellow: 33
    };
    matcher = /{([a-z]+)}/gi;
    return msg.replace(matcher, function(match, idx) {
      return "[" + styles[idx] + "m";
    });
  };

  callout = function(msg) {
    return msg.replace(new RegExp("@" + nick + "\\b", 'g'), function(match) {
      return "{magenta}" + match + "{reset}";
    });
  };

  messageList = [];

  msgLine = 0;

  printNewMessage = function(obj) {
    var _i, _len;
    obj.payload = callout(obj.payload);
    messageList.push(obj);
    charm.push();
    if (msgLine > process.stdout.getWindowSize()[1] - 4) {
      messageList.shift();
      charm.erase('screen');
      msgLine = 0;
      for (_i = 0, _len = messageList.length; _i < _len; _i++) {
        obj = messageList[_i];
        charm.position(0, ++msgLine);
        if (obj.nick === nick) {
          charm.write(stylize("[{" + obj.color + "}{bold}" + obj.nick + "{reset}] " + obj.payload));
        } else {
          charm.write(stylize("[{" + obj.color + "}" + obj.nick + "{reset}] " + obj.payload));
        }
      }
      charm.write('\u0007');
      charm.display('reset');
      drawPresence();
    } else {
      charm.position(0, ++msgLine);
      charm.write('\u0007');
      if (obj.nick === nick) {
        charm.write(stylize("[{" + obj.color + "}{bold}" + obj.nick + "{reset}] " + obj.payload));
      } else {
        charm.write(stylize("[{" + obj.color + "}" + obj.nick + "{reset}] " + obj.payload));
      }
      charm.display('reset');
    }
    charm.pop();
    return positionForInput();
  };

  positionForInput = function() {
    charm.position(0, process.stdout.getWindowSize()[1] - 2);
    charm.background('blue');
    charm.erase('end');
    charm.position(0, process.stdout.getWindowSize()[1] - 1);
    charm.background('black');
    return charm.erase('end');
  };

  drawPresence = function() {
    var address, i, line, obj, size, _i;
    charm.push();
    line = 0;
    size = process.stdout.getWindowSize();
    for (i = _i = 0; _i <= 10; i = ++_i) {
      charm.position(size[0] - 10, line);
      charm.write("         ");
      line++;
    }
    line = 0;
    for (address in tcpconnection.connections) {
      for (port in tcpconnection.connections[address]) {
        obj = tcpconnection.connections[address][port];
        line++;
        charm.position(size[0] - 10, line);
        charm.write(stylize("{" + obj.color + "}" + obj.nick + "{reset}"));
      }
    }
    return charm.pop();
  };

  see = function(obj) {
    return present[obj.nick] = {
      when: new Date(),
      color: obj.color
    };
  };

  sendRaw = function(msg) {
    msg = new Buffer(msg);
    return client.send(msg, 0, msg.length, port, '224.0.0.0');
  };

  send = function(obj) {
    var msg;
    if (password) {
      iron.seal(obj, password, iron.defaults, function(err, sealed) {
        return sendRaw(sealed);
      });
    } else {
      msg = JSON.stringify(obj);
      sendRaw(msg);
    }
    if (obj.payload != null) {
      return positionForInput();
    }
  };

  positionForInput();

  setInterval(drawPresence, 5000);

  stdin = process.openStdin();

  stdin.on('data', function(msg) {
    var obj;
    obj = {
      payload: msg.toString(),
      nick: nick.toString(),
      color: color.toString()
    };
    return tcpconnection.send(obj);
  });

  parseMsg = function(obj) {
    if (obj.payload != null) {
      return printNewMessage(obj);
    } else if (obj.address != null) {
      return tcpconnection.connectTo(obj);
    }
  };

  parseRawMsg = function(str) {
    var obj;
    if (password) {
      return iron.unseal(str.toString(), password, iron.defaults, function(err, obj) {
        if (obj == null) {
          return;
        }
        return parseMsg(obj);
      });
    } else {
      try {
        obj = JSON.parse(str);
        return parseMsg(obj);
      } catch (_error) {}
    }
  };

  server.on('message', function(str, rinfo) {
    return parseRawMsg(str);
  });

  tcpconnection = new TcpConnection;

}).call(this);
